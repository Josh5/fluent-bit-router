# ---------------
# Fluent-Bit Router for Docker Swarm
#
# ---------------
# Config (paste into portainer advance env text input):
#
# <config_start>
#   #@ Placement
#   #-  PLACEMENT_CONSTRAINT
#   #-    Constraint used by Swarm to decide which node runs this container.
#   #-    Examples:
#   #-        - node.hostname==<hostname>
#   #-        - engine.labels.fs-access.<worker-hostname>.mnt==true
#   #-        - node.role!=manager
#   PLACEMENT_CONSTRAINT=node.platform.os==linux
#   #@ Resource Limits
#   #-  - FLUENTBIT_MEMLIMIT -
#   #-    Limit Fluent-Bit container memory.
#   FLUENTBIT_MEMLIMIT=400m
#   #@ Container Paths
#   #-  FLUENTBIT_STORAGE_PATH
#   #-    Host path for Fluent Bit persistent storage (chunks, DB, offsets).
#   FLUENTBIT_STORAGE_PATH=./appdata/fluent-bit/storage
#   #-  FLUENTBIT_CERTS_PATH
#   #-    Host path for TLS certificates (mounted into the container).
#   FLUENTBIT_CERTS_PATH=./appdata/fluent-bit/certs
#   #@ Core Fluent-Bit Settings
#   #-  NGINX_PORT
#   #-    The port to run the NGINX server on.
#   NGINX_PORT=3200
#   #@ Core Fluent-Bit Settings
#   #-  HOST_HOSTNAME
#   #-    Hostname used inside Fluent Bit (self_hostname / cert CN where relevant).
#   HOST_HOSTNAME=fluent-bit-router
#   #-  FLUENT_BIT_LOG_LEVEL
#   #-    Log verbosity of Fluent Bit: error | warn | info | debug | trace
#   FLUENT_BIT_LOG_LEVEL=info
#   #-  FLUENTBIT_PUBLISHED_HTTP_SERVER_PORT
#   #-    Host port to publish Fluent Bitâ€™s internal HTTP server (default 2020).
#   FLUENTBIT_PUBLISHED_HTTP_SERVER_PORT=2020
#   #-  FLUENT_BIT_TAG_PREFIX
#   #-    Prefix applied to record tags for filtering/routing.
#   FLUENT_BIT_TAG_PREFIX=flb.
#   #@ TLS Certificates
#   #-  FLUENTBIT_USE_EXISTING_CERT
#   #-    Use an existing TLS certificate/key instead of generating new ones.
#   FLUENTBIT_USE_EXISTING_CERT=false
#   #-  FLUENTBIT_EXISTING_CERT_PATH
#   #-    Path INSIDE container to existing certificate file.
#   FLUENTBIT_EXISTING_CERT_PATH=/fluent-bit-data/certs/1.pem
#   #-  FLUENTBIT_EXISTING_KEY_PATH
#   #-    Path INSIDE container to existing private key file.
#   FLUENTBIT_EXISTING_KEY_PATH=/fluent-bit-data/certs/1.key
#   #-  USE_CERTBOT_TO_GENERATE_KEY
#   #-    If true, run Certbot to issue a certificate via ACME challenge.
#   USE_CERTBOT_TO_GENERATE_KEY=false
#   #-  CERT_FQDN
#   #-    Fully qualified domain name used for certificate CN.
#   CERT_FQDN=
#   #-  CERT_EMAIL
#   #-    Email address for Certbot registration/renewal.
#   CERT_EMAIL=
#   #@ HTTP Input
#   #-  ENABLE_FLUENTBIT_HTTP_INPUT
#   #-    Enable Fluent Bit HTTP input listener (ingest logs via HTTP).
#   ENABLE_FLUENTBIT_HTTP_INPUT=false
#   #-  FLUENTBIT_HTTP_INPUT_PORT
#   #-    Container port for HTTP input (default 24280).
#   FLUENTBIT_HTTP_INPUT_PORT=24280
#   #@ Forward TLS Input
#   #-  ENABLE_FLUENTBIT_TLS_FORWARD_INPUT
#   #-    Enable TLS-secured Forward input for receiving logs.
#   ENABLE_FLUENTBIT_TLS_FORWARD_INPUT=false
#   #-  FLUENTBIT_TLS_FORWARD_INPUT_PORT
#   #-    Container port for TLS Forward input (default 24224).
#   FLUENTBIT_TLS_FORWARD_INPUT_PORT=24224
#   #-  FLUENTBIT_TLS_FORWARD_INPUT_SHARED_KEY
#   #-    Shared key required for TLS Forward authentication.
#   FLUENTBIT_TLS_FORWARD_INPUT_SHARED_KEY=123456789
#   #-  FLUENTBIT_TLS_FORWARD_INPUT_VERIFY
#   #-    Verify client certificates? on|off (default: off).
#   FLUENTBIT_TLS_FORWARD_INPUT_VERIFY=off
#   #@ Forward Plaintext Input
#   #-  ENABLE_FLUENTBIT_PT_FORWARD_INPUT
#   #-    Enable plaintext Forward input (unsecured).
#   ENABLE_FLUENTBIT_PT_FORWARD_INPUT=false
#   #-  FLUENTBIT_PT_FORWARD_INPUT_PORT
#   #-    Container port for plaintext Forward input (default 24228).
#   FLUENTBIT_PT_FORWARD_INPUT_PORT=24228
#   #@ Forward Plaintext Input
#   #-  ENABLE_FLUENTBIT_STDOUT_OUTPUT
#   #-    Enable STDOUT output.
#   ENABLE_FLUENTBIT_STDOUT_OUTPUT=false
#   #@ Forward TLS Output
#   #-  ENABLE_FLUENTBIT_TLS_FORWARD_OUTPUT
#   #-    Enable sending logs to an upstream Fluent Bit/Fluentd via TLS Forward.
#   ENABLE_FLUENTBIT_TLS_FORWARD_OUTPUT=false
#   #-  FLUENTBIT_TLS_FORWARD_OUTPUT_HOST
#   #-    Hostname of the upstream TLS Forward receiver.
#   FLUENTBIT_TLS_FORWARD_OUTPUT_HOST=
#   #-  FLUENTBIT_TLS_FORWARD_OUTPUT_PORT
#   #-    Port of the upstream TLS Forward receiver.
#   FLUENTBIT_TLS_FORWARD_OUTPUT_PORT=
#   #-  FLUENTBIT_TLS_FORWARD_OUTPUT_SHARED_KEY
#   #-    Shared key for authenticating with upstream TLS Forward.
#   FLUENTBIT_TLS_FORWARD_OUTPUT_SHARED_KEY=
#   #-  FLUENTBIT_TLS_FORWARD_OUTPUT_VERIFY
#   #-    Verify TLS certificates from the upstream server? on|off.
#   FLUENTBIT_TLS_FORWARD_OUTPUT_VERIFY=off
#   #@ Forward Plaintext Output
#   #-  ENABLE_FLUENTBIT_PT_FORWARD_OUTPUT
#   #-    Enable sending logs to an upstream Fluent Bit/Fluentd via plaintext Forward.
#   ENABLE_FLUENTBIT_PT_FORWARD_OUTPUT=false
#   #-  FLUENTBIT_PT_FORWARD_OUTPUT_HOST
#   #-    Hostname of the upstream plaintext Forward receiver.
#   FLUENTBIT_PT_FORWARD_OUTPUT_HOST=
#   #-  FLUENTBIT_PT_FORWARD_OUTPUT_PORT
#   #-    Port of the upstream plaintext Forward receiver.
#   FLUENTBIT_PT_FORWARD_OUTPUT_PORT=
#   #@ Grafana Loki Output
#   #-  ENABLE_FLUENTBIT_GRAFANA_LOKI_OUTPUT
#   #-    Enable output to Grafana Loki.
#   ENABLE_FLUENTBIT_GRAFANA_LOKI_OUTPUT=false
#   #-  GRAFANA_LOKI_HOST
#   #-    Hostname/service of the Loki gateway (inside the Swarm network).
#   GRAFANA_LOKI_HOST=loki
#   #-  GRAFANA_LOKI_PORT
#   #-    Loki HTTP port (default: 3100).
#   GRAFANA_LOKI_PORT=3100
#   #-  GRAFANA_LOKI_URI
#   #-    Loki push path (default: /loki/api/v1/push).
#   GRAFANA_LOKI_URI=/loki/api/v1/push
#   #@ Graylog GELF Output
#   #-  ENABLE_GRAYLOG_GELF_OUTPUT
#   #-    Enable sending logs to Graylog via GELF.
#   ENABLE_GRAYLOG_GELF_OUTPUT=false
#   #-  GRAYLOG_GELF_HOST
#   #-    Hostname or service name of the Graylog GELF input.
#   GRAYLOG_GELF_HOST=graylog
#   #-  GRAYLOG_GELF_PORT
#   #-    Port of the Graylog GELF input (usually 12201).
#   GRAYLOG_GELF_PORT=12201
#   #-  GRAYLOG_GELF_MODE
#   #-    Transport protocol for GELF: tcp | udp (default: tcp).
#   GRAYLOG_GELF_MODE=tcp
#   #@ S3 Cold Storage Output
#   #-  ENABLE_S3_BUCKET_COLD_STORAGE_OUTPUT
#   #-    Enable archiving logs to an S3 bucket (credentials must be provided by the runtime, e.g., env/role).
#   ENABLE_S3_BUCKET_COLD_STORAGE_OUTPUT=false
#   #-  AWS_COLD_STORAGE_BUCKET_NAME
#   #-    Name of the S3 bucket used for cold storage.
#   AWS_COLD_STORAGE_BUCKET_NAME=
#   #-  AWS_COLD_STORAGE_BUCKET_REGION
#   #-    AWS region of the S3 bucket (e.g., ap-southeast-2).
#   AWS_COLD_STORAGE_BUCKET_REGION=
# <config_end>

#
# ---------------
# Setup Script
#
# <script_start>
#   > mkdir -p \
#   >     ${FLUENTBIT_STORAGE_PATH:?} \
#   >     ${FLUENTBIT_CERTS_PATH:?}
#   > echo && echo "$(cd "${FLUENTBIT_STORAGE_PATH:?}" && pwd)" && ls -la ${FLUENTBIT_STORAGE_PATH:?}
#   > echo && echo "$(cd "${FLUENTBIT_CERTS_PATH:?}" && pwd)" && ls -la ${FLUENTBIT_CERTS_PATH:?}
# <script_end>
#
# ---------------
---
networks:
  swarm-public:
    # NOTE: This network needs to be manually created and needs to
    #       be configured for manual container attachment
    external: true
  private-net:

volumes:
  # Location of the Letsencrypt acme-challenge
  fluentbit_certbot_data:
    driver: local

services:
  # -- Fluent-Bit --
  #
  # Fluent Bit is a super fast, lightweight, and highly scalable logging and metrics processor and forwarder.
  # It is the preferred choice for cloud and containerized environments.
  #
  fluent-bit-router:
    image: ghcr.io/josh5/fluent-bit-router:latest
    deploy:
      replicas: 1
      restart_policy:
        condition: any
        delay: 20s
      placement:
        constraints:
          - ${PLACEMENT_CONSTRAINT:-node.platform.os==linux}
      resources:
        limits:
          memory: ${FLUENTBIT_MEMLIMIT:-400m}
    entrypoint:
      - 'sh'
      - '-c'
      - |
        wait-for-it fluent-bit-router-cert-challenge:$${NGINX_PORT:-3200} --timeout=20 -- sleep 5
        exec /usr/bin/tini -- /entrypoint.sh

    # NETWORK:
    networks:
      - swarm-public
      - private-net
    ports:
      # Fluent Bit HTTP server (can be used for health checks)
      - target: 2020
        published: ${FLUENTBIT_PUBLISHED_HTTP_SERVER_PORT:-2020}
        protocol: tcp
        mode: host
      # Fluent Bit log ingest ports
      - target: ${FLUENTBIT_HTTP_INPUT_PORT:-24280}
        published: ${FLUENTBIT_HTTP_INPUT_PORT:-24280}
        protocol: tcp
        mode: host
      # Forward input configured with TLS certificates
      - target: ${FLUENTBIT_TLS_FORWARD_INPUT_PORT:-24224}
        published: ${FLUENTBIT_TLS_FORWARD_INPUT_PORT:-24224}
        protocol: tcp
        mode: host
      - target: ${FLUENTBIT_TLS_FORWARD_INPUT_PORT:-24224}
        published: ${FLUENTBIT_TLS_FORWARD_INPUT_PORT:-24224}
        protocol: udp
        mode: host
      # Forward input configured PT only (for local docker logs, etc.)
      - target: ${FLUENTBIT_PT_FORWARD_INPUT_PORT:-24228}
        published: ${FLUENTBIT_PT_FORWARD_INPUT_PORT:-24228}
        protocol: tcp
        mode: host
      - target: ${FLUENTBIT_PT_FORWARD_INPUT_PORT:-24228}
        published: ${FLUENTBIT_PT_FORWARD_INPUT_PORT:-24228}
        protocol: udp
        mode: host

    # ENVIRONMENT:
    environment:
      NGINX_PORT: ${NGINX_PORT:-3200}
      # -> Application:
      FLUENT_BIT_LOG_LEVEL: ${FLUENT_BIT_LOG_LEVEL:-info}
      HOST_HOSTNAME: ${HOST_HOSTNAME:-grafana-fluent-bit}
      FLUENT_BIT_TAG_PREFIX: ${FLUENT_BIT_TAG_PREFIX:-flb.}
      FLUENT_STORAGE_PATH: /fluent-bit-data/storage

      # -> Certificates
      CERTIFICATES_DIRECTORY: /fluent-bit-data/certs
      USE_EXISTING_CERT: ${FLUENTBIT_USE_EXISTING_CERT:-false}
      EXISTING_CERT_PATH: ${FLUENTBIT_EXISTING_CERT_PATH:-}
      EXISTING_KEY_PATH: ${FLUENTBIT_EXISTING_KEY_PATH:-}
      USE_CERTBOT_TO_GENERATE_KEY: ${USE_CERTBOT_TO_GENERATE_KEY:-false}
      CERT_FQDN: ${CERT_FQDN:-}
      CERT_EMAIL: ${CERT_EMAIL:-}

      # -> Inputs
      # |--> HTTP Input
      ENABLE_HTTP_INPUT: ${ENABLE_FLUENTBIT_HTTP_INPUT:-false}
      HTTP_INPUT_PORT: ${FLUENTBIT_HTTP_INPUT_PORT:-24280}

      # |--> Forward TLS Input
      ENABLE_TLS_FORWARD_INPUT: ${ENABLE_FLUENTBIT_TLS_FORWARD_INPUT:-false}
      TLS_FORWARD_INPUT_PORT: ${FLUENTBIT_TLS_FORWARD_INPUT_PORT:-24224}
      TLS_FORWARD_INPUT_SHARED_KEY: ${FLUENTBIT_TLS_FORWARD_INPUT_SHARED_KEY:-}
      TLS_FORWARD_INPUT_VERIFY: ${FLUENTBIT_TLS_FORWARD_INPUT_VERIFY:-off}

      # |--> Forward PT Input
      ENABLE_PT_FORWARD_INPUT: ${ENABLE_FLUENTBIT_PT_FORWARD_INPUT:-false}
      PT_FORWARD_INPUT_PORT: ${FLUENTBIT_PT_FORWARD_INPUT_PORT:-24228}

      # -> Outputs
      # |--> STDOUT Output
      ENABLE_STDOUT_OUTPUT: ${ENABLE_FLUENTBIT_STDOUT_OUTPUT:-false}

      # |--> Forward TLS Output
      ENABLE_TLS_FORWARD_OUTPUT: ${ENABLE_FLUENTBIT_TLS_FORWARD_OUTPUT:-false}
      TLS_FORWARD_OUTPUT_HOST: ${FLUENTBIT_TLS_FORWARD_OUTPUT_HOST:-}
      TLS_FORWARD_OUTPUT_PORT: ${FLUENTBIT_TLS_FORWARD_OUTPUT_PORT:-}
      TLS_FORWARD_OUTPUT_SHARED_KEY: ${FLUENTBIT_TLS_FORWARD_OUTPUT_SHARED_KEY:-}
      TLS_FORWARD_OUTPUT_VERIFY: ${FLUENTBIT_TLS_FORWARD_OUTPUT_VERIFY:-off}

      # |--> Forward PT Output
      ENABLE_PT_FORWARD_OUTPUT: ${ENABLE_FLUENTBIT_PT_FORWARD_OUTPUT:-false}
      PT_FORWARD_OUTPUT_HOST: ${FLUENTBIT_PT_FORWARD_OUTPUT_HOST:-}
      PT_FORWARD_OUTPUT_PORT: ${FLUENTBIT_PT_FORWARD_OUTPUT_PORT:-}

      # |--> Grafana Loki Output
      ENABLE_GRAFANA_LOKI_OUTPUT: ${ENABLE_FLUENTBIT_GRAFANA_LOKI_OUTPUT:-false}
      GRAFANA_LOKI_HOST: ${GRAFANA_LOKI_HOST:-loki}
      GRAFANA_LOKI_PORT: ${GRAFANA_LOKI_PORT:-3100}
      GRAFANA_LOKI_URI: ${GRAFANA_LOKI_URI:-/loki/api/v1/push}

      # |--> Graylog GELF Output (MISSING BEFORE)
      ENABLE_GRAYLOG_GELF_OUTPUT: ${ENABLE_GRAYLOG_GELF_OUTPUT:-false}
      # Optional future env (entrypoint currently hardcodes host/port)
      GRAYLOG_GELF_HOST: ${GRAYLOG_GELF_HOST:-graylog}
      GRAYLOG_GELF_PORT: ${GRAYLOG_GELF_PORT:-12201}
      GRAYLOG_GELF_MODE: ${GRAYLOG_GELF_MODE:-tcp}

      # |--> S3 Cold Storage (MISSING BEFORE)
      ENABLE_S3_BUCKET_COLD_STORAGE_OUTPUT: ${ENABLE_S3_BUCKET_COLD_STORAGE_OUTPUT:-false}
      AWS_COLD_STORAGE_BUCKET_NAME: ${AWS_COLD_STORAGE_BUCKET_NAME:-}
      AWS_COLD_STORAGE_BUCKET_REGION: ${AWS_COLD_STORAGE_BUCKET_REGION:-}

    # VOLUMES:
    volumes:
      - type: bind
        source: ${FLUENTBIT_STORAGE_PATH:?}
        target: /fluent-bit-data/storage
      - type: bind
        source: ${FLUENTBIT_CERTS_PATH:?}
        target: /fluent-bit-data/certs
      - type: volume
        source: fluentbit_certbot_data
        target: /var/www/certbot

  # -- Nginx Certificate Generator --
  #
  # A simple Nginx container that serves the ACME HTTP-01 challenge files
  # from /var/www/certbot. Fluent Bitâ€™s entrypoint can wait for this service
  # to be ready so Certbot can obtain or renew TLS certificates.
  # It also responds with 200 OK on / and /ping for basic health checks.
  #
  fluent-bit-router-cert-challenge:
    image: library/nginx:latest
    deploy:
      replicas: 1
      restart_policy:
        condition: on-failure
        delay: 10s
      placement:
        constraints:
          - ${PLACEMENT_CONSTRAINT:-node.platform.os==linux}
      resources:
        limits:
          memory: 200M
        reservations:
          memory: 100M
    healthcheck:
      test: ['CMD', 'service', 'nginx', 'status']
      interval: 10s
      timeout: 5s
      retries: 5
    entrypoint:
      - '/bin/sh'
      - '-c'
      - |
        set -e
        cat <<EOF > /etc/nginx/nginx.conf
        user  nginx;
        worker_processes  5;  ## Default: 1

        events {
          worker_connections  1024;
        }

        http {
          resolver 127.0.0.11 valid=10s;

          default_type application/octet-stream;
          log_format   main '\$$remote_addr - \$$remote_user [\$$time_local]  \$$status '
            '"\$$request" \$$body_bytes_sent "\$$http_referer" '
            '"\$$http_user_agent" "\$$http_x_forwarded_for"';
          access_log   /dev/stderr  main;
          sendfile     on;
          tcp_nopush   on;

          server {
            listen                $${NGINX_PORT};
            client_max_body_size  200M;

            location = / {
              return 200 'OK';
              auth_basic off;
            }

            location = /ping {
              return 200 'OK';
              auth_basic off;
            }

            location /.well-known/acme-challenge/ {
                root /var/www/certbot;
            }
          }
        }
        EOF
        cat /etc/nginx/nginx.conf

        echo "Running Nginx entrypoint..."
        /docker-entrypoint.sh nginx -g "daemon off;"
        echo

    # NETWORK:
    networks:
      - private-net
      - swarm-public
    ports:
      # Nginx HTTP server
      - target: ${NGINX_PORT:-3200}
        published: ${NGINX_PORT:-3200}
        protocol: tcp
        mode: host

    # ENVIRONMENT:
    environment:
      NGINX_PORT: ${NGINX_PORT:-3200}

    # VOLUMES:
    volumes:
      - type: volume
        source: fluentbit_certbot_data
        target: /var/www/certbot
